use libicsneo_sys::{
    neodevice_t, neoevent_t, neomessage_can_error_t, neomessage_can_t, neomessage_eth_t,
    neomessage_frame_t, neomessage_lin_t, neomessage_t, neoversion_t,
};

use std::{ffi::CStr, fmt, str::Utf8Error};

pub type Result<T> = std::result::Result<T, Error>;

/// All errors that are returned from this library will be contained here
#[derive(Debug)]
pub enum Error {
    /// icsneo_getLastError() happened.
    ErrorOccurred(NeoEvent),
    /// Critical API error that shouldn't have happened.
    CriticalError(String),
    /// API reported the NeoDevice object is not valid.
    DeviceInvalid,
}

impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self {
            Self::ErrorOccurred(e) => write!(f, "Error Occurred: ({:#?})", e),
            Self::CriticalError(s) => write!(f, "Critical Error: {s}"),
            Self::DeviceInvalid => write!(f, "Device Invalid"),
        }
    }
}

impl From<Utf8Error> for Error {
    fn from(value: Utf8Error) -> Self {
        Self::CriticalError(value.to_string())
    }
}

/// Used with [get_version](get_version)
#[derive(Debug, Default, Clone, PartialEq)]
#[repr(transparent)]
pub struct NeoVersion(pub neoversion_t);

impl NeoVersion {
    /// Returns a full version as a string.
    ///
    /// Example:
    /// ```
    /// use libicsneo::get_version;
    ///
    /// let version = get_version();
    /// println!("{}", version.version_as_str())
    /// ```
    pub fn version_as_str(&self) -> Result<String> {
        let metadata = self.metadata()?;
        let build_branch = self.build_branch()?;
        let build_tag = self.build_tag()?;

        Ok(format!(
            "v{}.{}.{} {metadata} {build_branch} {build_tag}",
            self.major(),
            self.minor(),
            self.patch()
        ))
    }

    /// Returns the major version
    pub fn major(&self) -> u16 {
        self.0.major
    }

    /// Returns the minor version
    pub fn minor(&self) -> u16 {
        self.0.minor
    }

    /// Returns the patch version
    pub fn patch(&self) -> u16 {
        self.0.patch
    }

    /// Returns the metadata version
    pub fn metadata(&self) -> Result<&str> {
        let value = unsafe { CStr::from_ptr(self.0.metadata).to_str().unwrap() };
        Ok(value)
    }

    /// Returns the branch version
    pub fn build_branch(&self) -> Result<&str> {
        let value = unsafe { CStr::from_ptr(self.0.buildBranch).to_str().unwrap() };
        Ok(value)
    }

    /// Returns the build tag version
    pub fn build_tag(&self) -> Result<&str> {
        let value = unsafe { CStr::from_ptr(self.0.buildTag).to_str().unwrap() };
        Ok(value)
    }
}

/// Contains metadata and handle to Intrepid Devices.
#[derive(Debug, Default, PartialEq)]
#[repr(transparent)]
pub struct NeoDevice(pub neodevice_t);

impl NeoDevice {
    pub fn serial(&self) -> String {
        unsafe {
            CStr::from_ptr(self.0.serial.as_ptr())
                .to_str()
                .unwrap()
                .to_string()
        }
    }
}

/// Events generated by the API
#[derive(Debug, Default, PartialEq)]
#[repr(transparent)]
pub struct NeoEvent(pub neoevent_t);

impl NeoEvent {
    pub fn description(&self) -> Result<String> {
        Ok(unsafe { CStr::from_ptr(self.0.description).to_str()?.to_string() })
    }

    pub fn serial(&self) -> Result<String> {
        Ok(unsafe { CStr::from_ptr(self.0.serial.as_ptr()).to_str()?.to_string() })
    }
}

macro_rules! define_message {
    ($name:ident, $inner_name:ident) => {
        #[derive(Clone, Default)]
        #[repr(transparent)]
        pub struct $name(pub $inner_name);

        // We are making the assumption here that everything is thread safe.
        unsafe impl Send for $name {}
    };
}

macro_rules! define_message_from {
    ($name:ident, $from_name:ident) => {
        impl From<$from_name> for $name {
            fn from(msg: $from_name) -> Self {
                unsafe { std::mem::transmute::<$from_name, $name>(msg) }
            }
        }
    };
}

define_message!(NeoMessage, neomessage_t);
define_message!(NeoMessageFrame, neomessage_frame_t);
define_message!(NeoMessageCan, neomessage_can_t);
define_message!(NeoMessageCanError, neomessage_can_error_t);
define_message!(NeoMessageLin, neomessage_lin_t);
define_message!(NeoMessageEth, neomessage_eth_t);

define_message_from!(NeoMessageFrame, NeoMessage);
define_message_from!(NeoMessageFrame, NeoMessageCan);
define_message_from!(NeoMessageFrame, NeoMessageCanError);
define_message_from!(NeoMessageFrame, NeoMessageLin);
define_message_from!(NeoMessageFrame, NeoMessageEth);

define_message_from!(NeoMessageCan, NeoMessage);
define_message_from!(NeoMessageCan, NeoMessageFrame);
define_message_from!(NeoMessageCan, NeoMessageCanError);
define_message_from!(NeoMessageCan, NeoMessageLin);
define_message_from!(NeoMessageCan, NeoMessageEth);

define_message_from!(NeoMessageCanError, NeoMessage);
define_message_from!(NeoMessageCanError, NeoMessageFrame);
define_message_from!(NeoMessageCanError, NeoMessageCan);
define_message_from!(NeoMessageCanError, NeoMessageLin);
define_message_from!(NeoMessageCanError, NeoMessageEth);

define_message_from!(NeoMessageEth, NeoMessage);
define_message_from!(NeoMessageEth, NeoMessageFrame);
define_message_from!(NeoMessageEth, NeoMessageCan);
define_message_from!(NeoMessageEth, NeoMessageLin);
define_message_from!(NeoMessageEth, NeoMessageCanError);
